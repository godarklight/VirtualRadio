using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Numerics;
using System.Threading;
using System.IO;
using VirtualRadio.Common;

namespace VirtualRadio
{
    public class TcpServer
    {
        TcpListener listener;
        List<Client> clients = new List<Client>();
        const double samplesSec = 250000;
        const double carrierFreq = 10000;
        const double carrierFreq2 = -20000;
        const double carrierFreq3 = 50000;
        const double fmBandwidth = 12500;
        const int samplesPerMs = (int)(samplesSec / 1000);
        double amplitudePerSignal = 0.2;

        public TcpServer()
        {
            listener = new TcpListener(new IPEndPoint(IPAddress.IPv6Any, 1234));
            listener.Server.DualMode = true;
            listener.Start();
            listener.BeginAcceptTcpClient(ConnectCallback, listener);
        }

        public void ConnectCallback(IAsyncResult ar)
        {
            TcpClient tcpClient = listener.EndAcceptTcpClient(ar);
            Client client = new Client(tcpClient);
            clients.Add(client);
        }

        public void Run()
        {
            /*
            IFilter carrierFilterI = new WindowedSinc(ifFreq, ifFreq / 2, samplesSec, true);
            IFilter carrierFilterQ = new WindowedSinc(ifFreq, ifFreq / 2, samplesSec, true);
            */

            double[] IData = LoadWav("test.wav");
            Console.WriteLine("Filtered input signal");
            double[] AData = LoadWav("test2.wav");
            Console.WriteLine("Filtered input signal2");
            double[] QData = GenerateHilbert(IData);
            Console.WriteLine("Generated Q Data");


            /*
            double audioAngle = 5000;
            for (int i = 0; i < IData.Length; i++)
            {
                double[] ssbData = Math.Cos() IData[i]
            }
            */


            while (clients.Count == 0)
            {
                Thread.Sleep(1000);
            }

            long startTime = DateTime.UtcNow.Ticks;

            //Carrier tracking
            double carrierAngle = 0;
            double carrierAngle2 = 0;
            double carrierAngle3 = 0;

            //Output data
            byte[] sendBuffer = new byte[samplesPerMs * 2];

            //Time sync
            long targetMs = 0;
            long totalSamples = 0;
            bool running = true;

            while (running)
            {
                while (clients.Count == 0)
                {
                    startTime = DateTime.UtcNow.Ticks;
                    targetMs = 0;
                    totalSamples = 0;
                    Thread.Sleep(1000);
                }
                targetMs++;

                for (int i = 0; i < samplesPerMs; i++)
                {
                    //Read signals
                    int readSample = (int)(totalSamples * 48000 / samplesSec);
                    double aData = 0;
                    if (readSample < AData.Length)
                    {
                        aData = AData[readSample];
                    }
                    double qData = 0;
                    if (readSample < QData.Length)
                    {
                        qData = QData[readSample];
                    }
                    double iData = 0;
                    if (readSample < IData.Length)
                    {
                        iData = IData[readSample];
                    }

                    if (readSample > QData.Length)
                    {
                        targetMs = 0;
                        startTime = DateTime.UtcNow.Ticks;
                        totalSamples = 0;
                    }

                    totalSamples++;

                    double carrierReal = 0;
                    double carrierImaginary = 0;


                    //Add SSB DSSTV
                    double ssbData = Math.Cos(carrierAngle) * iData + Math.Sin(carrierAngle) * qData;
                    double ssbData90 = Math.Sin(carrierAngle) * iData - Math.Cos(carrierAngle) * qData;
                    carrierReal = amplitudePerSignal * ssbData;
                    carrierImaginary = amplitudePerSignal * ssbData90;

                    //Add AM SSTV
                    double amShift = (aData + 1.0) / 2.0;
                    carrierReal += amplitudePerSignal * Math.Cos(carrierAngle2) * amShift;
                    carrierImaginary += amplitudePerSignal * Math.Sin(carrierAngle2) * amShift;

                    //Add FM DSSTV
                    double fmShift = (fmBandwidth / 2) * iData;
                    carrierReal += amplitudePerSignal * Math.Cos(carrierAngle3);
                    carrierImaginary += amplitudePerSignal * Math.Sin(carrierAngle3);

                    sendBuffer[i * 2] = (byte)((carrierReal * 127) + 128);
                    sendBuffer[(i * 2) + 1] = (byte)((carrierImaginary * 127) + 128);

                    carrierAngle += (carrierFreq * Math.Tau / samplesSec) % Math.Tau;
                    carrierAngle2 += (carrierFreq2 * Math.Tau / samplesSec) % Math.Tau;
                    carrierAngle3 += ((carrierFreq3 + fmShift) * Math.Tau / samplesSec) % Math.Tau;
                }

                //TCP send and disconnect
                Client removeClient = null;
                foreach (Client c in clients)
                {
                    try
                    {
                        c.tcpClient.GetStream().Write(sendBuffer, 0, sendBuffer.Length);
                    }
                    catch
                    {
                        removeClient = c;
                    }
                }
                if (removeClient != null)
                {
                    clients.Remove(removeClient);
                }

                //Time tracking
                long currentTime = DateTime.UtcNow.Ticks;
                double timeElapsed = (currentTime - startTime) / (double)TimeSpan.TicksPerMillisecond;
                if (targetMs > timeElapsed)
                {
                    Thread.Sleep(1);
                }
            }
        }

        private static void WriteComplex(Complex[] input, string fileName)
        {
            if (File.Exists(fileName))
            {
                File.Delete(fileName);
            }
            using (StreamWriter sw = new StreamWriter(fileName))
            {
                for (int i = 0; i < input.Length; i++)
                {
                    sw.WriteLine($"{input[i].Real} {input[i].Imaginary}");
                }
            }
        }

        private static double[] LoadWav(string filename)
        {
            IFilter wavFilter = new WindowedSinc(9000, 2048, 48000, false);
            byte[] wavRaw = File.ReadAllBytes(filename);
            double[] wavSamples = new double[wavRaw.Length / 2];
            for (int i = 0; i < wavSamples.Length; i++)
            {
                short wavData = (short)(wavRaw[(i * 2)]);
                wavData += (short)(wavRaw[1 + (i * 2)] << 8);
                double wavAmplitude = wavData / (double)short.MaxValue;
                wavFilter.AddSample(wavAmplitude);
                wavSamples[i] = wavFilter.GetSample();
                wavSamples[i] = wavAmplitude;
            }
            return wavSamples;
        }

        private static void WriteWav(string filename, double[] samples)
        {
            using (FileStream fs = new FileStream(filename, FileMode.Create))
            {
                for (int i = 0; i < samples.Length; i++)
                {
                    short wavData = (short)(samples[i] * short.MaxValue);
                    byte lower = (byte)(wavData & 0xFF);
                    byte upper = (byte)((wavData & 0xFF00) >> 8);
                    fs.WriteByte(lower);
                    fs.WriteByte(upper);
                }
            }
        }

        private static double[] GenerateHilbert(double[] samples)
        {
            double[] output = new double[samples.Length];
            Complex[] transfer = new Complex[8192];
            int transfer8 = transfer.Length / 8;
            int samplesLeft = samples.Length;
            bool first = true;
            while (samplesLeft > transfer.Length)
            {
                int offset = samples.Length - samplesLeft;
                first = false;

                for (int i = 0; i < transfer.Length; i++)
                {
                    transfer[i] = samples[i + offset];
                }
                Complex[] transferHilbert = Hilbert.Calculate(transfer);
                //First 1/8th, we overlap
                for (int i = 0; i < transfer8; i++)
                {
                    double amplitude = i / (double)transfer8;
                    double oldAmplitude = 1 - amplitude;
                    if (first)
                    {
                        amplitude = 1;
                        oldAmplitude = 0;
                    }
                    output[offset + i] = transferHilbert[i].Imaginary * amplitude + output[offset + i] * oldAmplitude;
                }

                //Copy rest
                for (int i = transfer8; i < transfer.Length; i++)
                {
                    output[offset + i] = transferHilbert[i].Imaginary;
                }

                //Overlap last quarter
                samplesLeft -= (7 * transfer8);
            }
            return output;
        }
    }
}